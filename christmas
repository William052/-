<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ä¸AIå›å¿†ç”Ÿæˆå™¨ | Three.js & MediaPipe & Gemini API</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020202; /* æ·±é»‘èƒŒæ™¯ä»¥å¢å¼ºå¯¹æ¯”åº¦ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Video element hidden but active for MediaPipe */
        #video-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none; /* å…è®¸ç‚¹å‡»æŒ‰é’® */
        }

        h1 {
            margin: 0;
            font-weight: 100;
            font-size: 2rem;
            letter-spacing: 4px;
            font-family: 'Times New Roman', serif;
            color: #F8F0E3; 
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
            background: -webkit-linear-gradient(#eee, #D4AF37);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 0.8rem;
            letter-spacing: 2px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .status-box {
            margin-top: 10px;
            font-size: 0.9rem;
            background: rgba(10, 20, 15, 0.6);
            padding: 15px 20px;
            border-left: 2px solid #D4AF37;
            backdrop-filter: blur(10px);
            border-radius: 0 8px 8px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            pointer-events: all; /* å…è®¸ä¸æ§åˆ¶å…ƒç´ äº’åŠ¨ */
        }

        .instruction {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a1a, #000);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .loader-ring {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(212, 175, 55, 0.2);
            border-top: 2px solid #D4AF37;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .loading-text {
            margin-top: 25px;
            color: #D4AF37;
            font-weight: 300;
            font-size: 0.8rem;
            letter-spacing: 4px;
        }

        #cam-preview {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 140px;
            height: 105px;
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            overflow: hidden;
            background: #000;
            opacity: 0.6;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transform: scaleX(-1); /* é•œåƒæ•ˆæœ */
            transition: opacity 0.3s;
        }
        
        #cam-preview:hover {
            opacity: 1;
        }

        #cam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* æŒ‰é’®æ ·å¼ */
        #generate-captions-btn {
            background: linear-gradient(135deg, #D4AF37 0%, #FFD700 100%);
            color: #1a1a1a;
            border: none;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 4px 10px rgba(255, 215, 0, 0.3);
            transition: all 0.2s ease;
            width: 100%;
        }

        #generate-captions-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 215, 0, 0.5);
        }

        #generate-captions-btn:disabled {
            background: #444;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* é€‚åº”ç§»åŠ¨è®¾å¤‡çš„å“åº”å¼è®¾è®¡ */
        @media (max-width: 640px) {
            #ui-layer {
                top: 10px;
                left: 10px;
            }
            h1 {
                font-size: 1.5rem;
            }
            .subtitle {
                font-size: 0.7rem;
                letter-spacing: 1px;
            }
            .status-box {
                padding: 10px 15px;
                font-size: 0.8rem;
            }
            .instruction {
                font-size: 0.75rem;
            }
            #cam-preview {
                bottom: 10px;
                right: 10px;
                width: 100px;
                height: 75px;
            }
        }
    </style>
    
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- åŠ è½½å±å¹• -->
    <div id="loading">
        <div class="loader-ring"></div>
        <div class="loading-text">æ­£åœ¨åŠ è½½åœ£è¯é­”æ³•...</div>
    </div>

    <!-- UI ç•Œé¢ -->
    <div id="ui-layer">
        <h1>Merry Christmas Bella</h1>
        <div class="subtitle">æ‰‹åŠ¿äº’åŠ¨ä¸AIå›å¿†ç”Ÿæˆ</div>
        <div class="status-box">
            <div id="status-text" style="color: #44ff88; font-weight: bold;">ç³»ç»Ÿå‡†å¤‡ä¸­...</div>
            <div style="width: 100%; height: 1px; background: rgba(255,255,255,0.1); margin: 10px 0;"></div>
            <div class="instruction"><span>âœŠ</span> <span><b>COALESCE</b> (æ¡æ‹³èšåˆ - æ¢å¤æ ‘å½¢)</span></div>
            <div class="instruction"><span>ğŸ–</span> <span><b>EXPLODE</b> (å¼ æ‰‹åˆ†æ•£ - æ•£å¼€ç²’å­)</span></div>
            <div class="instruction"><span>ğŸ‘Œ</span> <span><b>FREEZE</b> (æåˆèšç„¦ - å†»ç»“å®šæ ¼)</span></div>
            <button id="generate-captions-btn" disabled>
                âœ¨ æ­£åœ¨åˆå§‹åŒ– AI...
            </button>
        </div>
    </div>

    <!-- æ‘„åƒå¤´å°é¢„è§ˆçª—å£ -->
    <div id="cam-preview">
        <video id="preview-video" playsinline muted></video>
    </div>

    <!-- MediaPipe éšè—è§†é¢‘è¾“å…¥ -->
    <video id="video-input" playsinline muted></video>

    <!-- 3D æ¸²æŸ“å®¹å™¨ -->
    <div id="canvas-container"></div>
    
    <!-- ä¾èµ–è„šæœ¬åŠ è½½: MediaPipe (éæ¨¡å—åŒ–åŠ è½½ä»¥è§£å†³ WASM è¿è¡Œæ—¶é”™è¯¯) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½®ä¸è®¾ç½® ---
        // Firebase å…¨å±€å˜é‡ (å¿…éœ€ä½†åœ¨æ­¤åº”ç”¨ä¸­æœªä½¿ç”¨ï¼Œä¿æŒå…¼å®¹æ€§)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
        
        // Gemini API é…ç½®
        const API_CONFIG = {
            model: "gemini-2.5-flash-preview-09-2025",
            apiKey: "", // API Keyç”±Canvasç¯å¢ƒè‡ªåŠ¨æä¾›
            apiUrl: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent",
            systemPrompt: "ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›æ„ä¸”çƒ­è¡·äºèŠ‚æ—¥çš„æ–‡æ¡ˆæ’°ç¨¿äººã€‚è¯·ç”¨ä¸­æ–‡ä¸ºä¸€å¼ åœ£è¯ä¸»é¢˜çš„å®¶åº­ç…§ç‰‡ç”Ÿæˆä¸€æ®µç®€çŸ­ã€ç§¯æã€å……æ»¡çˆ±æ„çš„ã€æœ€å¤š20å­—çš„æ ‡é¢˜æˆ–å›å¿†ã€‚",
            userQuery: "ä¸ºåœ£è¯èŠ‚ç”Ÿæˆä¸€æ®µæ¸©é¦¨çš„ä¸­æ–‡æ ‡é¢˜æˆ–ç¥ç¦è¯­ã€‚"
        };

        const CONFIG = {
            counts: {
                foliage: 1200,  // ç»¿è‰²æ ‘å¶åŸºåº•
                lights: 300,   // å‘å…‰å½©ç¯
                ornaments: 250, // è£…é¥°çƒ
                photos: 30
            },
            colors: {
                green: 0x073b22, // æ·±æ£®æ—ç»¿
                gold: 0xffd700,  // äº®é‡‘
                red: 0x8a0303,   // ä¸ç»’çº¢
                lightWarm: 0xffaa33, // æš–å…‰
                lightCool: 0xffffee, // å†·å…‰
            },
            bloom: {
                threshold: 0.15,
                strength: 1.8,  // è¾ƒé«˜çš„å…‰æ™•å¼ºåº¦
                radius: 0.8
            },
            cameraZ: 28
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const STATE = {
            mode: 'tree', // 'tree' (æ ‘å½¢), 'scatter' (åˆ†æ•£), 'focus' (èšç„¦)
            targetLerp: 0,
            currentLerp: 0,
            handPosition: { x: 0, y: 0 },
            rotationSpeed: 0.002,
            isPinching: false,
            photoObjects: [] // å­˜å‚¨ç…§ç‰‡ç½‘æ ¼å¼•ç”¨ï¼Œç”¨äºæ›´æ–°
        };

        // --- èµ„äº§ç”Ÿæˆ (ç¨‹åºåŒ–çº¹ç†) ---
        // åˆ›å»ºæˆ–æ›´æ–°å¸¦æœ‰æ ‡é¢˜çš„ç…§ç‰‡çº¹ç†
        function createPhotoTexture(index, caption) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 600;
            const ctx = canvas.getContext('2d');
            
            // å®ä¸½æ¥ç›¸æ¡†
            ctx.fillStyle = '#fdfdfd';
            ctx.shadowColor = "rgba(0,0,0,0.2)";
            ctx.shadowBlur = 10;
            ctx.fillRect(0, 0, 512, 600);
            ctx.shadowBlur = 0;
            
            // å›¾åƒåŒºåŸŸ (æ¸å˜)
            const grd = ctx.createLinearGradient(40, 40, 472, 472);
            grd.addColorStop(0, `hsl(${Math.random() * 60 + 330}, 60%, 70%)`); // æš–è‰²è°ƒ
            grd.addColorStop(1, `hsl(${Math.random() * 60}, 50%, 60%)`);
            ctx.fillStyle = grd;
            ctx.fillRect(30, 30, 452, 420);

            // å åŠ å›¾æ¡ˆ (å™ªå£°/çº¹ç†æ•ˆæœ)
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            for(let i=0; i<50; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*452+30, Math.random()*420+30, Math.random()*20, 0, Math.PI*2);
                ctx.fill();
            }

            // æ–‡æœ¬ (æ¥è‡ª LLM çš„æ ‡é¢˜æˆ–å ä½ç¬¦)
            ctx.fillStyle = '#222';
            ctx.font = 'bold 30px "Microsoft YaHei", sans-serif'; // ä½¿ç”¨æ›´é€‚åˆä¸­æ–‡çš„å­—ä½“
            ctx.textAlign = 'center';
            ctx.letterSpacing = "2px";
            // ä½¿ç”¨æä¾›çš„æ ‡é¢˜
            ctx.fillText(caption, 256, 500);
            
            ctx.font = 'italic 20px "Times New Roman"';
            ctx.fillStyle = '#666';
            ctx.fillText("Dec 25, 2025", 256, 540); // å‡æ—¥æœŸ

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 4;
            return tex;
        }

        // æ›´æ–°ç…§ç‰‡ç½‘æ ¼çš„æè´¨
        function updatePhotoMaterial(mesh, caption) {
            // é‡Šæ”¾æ—§çº¹ç†
            if (mesh.material.map) {
                mesh.material.map.dispose();
            }
            
            // åˆ›å»ºå¹¶åº”ç”¨æ–°çº¹ç†
            const newTexture = createPhotoTexture(0, caption); 
            mesh.material.map = newTexture;
            mesh.material.needsUpdate = true;
        }

        // --- 3D åœºæ™¯è®¾ç½® ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // è¾ƒæ·±çš„é›¾æ°”ä»¥å¢åŠ æ·±åº¦
        scene.fog = new THREE.FogExp2(0x020202, 0.025);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.cameraZ;
        camera.position.y = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // --- åæœŸå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
        );
        

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- å…‰ç…§ ---
        const ambientLight = new THREE.AmbientLight(0x111111, 1);
        scene.add(ambientLight);

        // ä¸»æš–å…‰
        const centerLight = new THREE.PointLight(0xffaa00, 3, 40);
        centerLight.position.set(0, 8, 0);
        scene.add(centerLight);

        // è½®å»“å…‰
        const rimLight = new THREE.DirectionalLight(0xffffff, 1.5);
        rimLight.position.set(-10, 20, -20);
        scene.add(rimLight);

        // è¡¥å…‰
        const frontLight = new THREE.DirectionalLight(0xffeedd, 1);
        frontLight.position.set(0, 10, 30);
        scene.add(frontLight);

        // --- æè´¨ ---
        const foliageMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.green, 
            roughness: 0.7, 
            metalness: 0.2, 
            flatShading: true 
        });

        const goldMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, 
            roughness: 0.1, 
            metalness: 0.8,
            envMapIntensity: 1
        });

        const redMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.red, 
            roughness: 0.4, 
            metalness: 0.4,
        });

        const lightMatWarm = new THREE.MeshBasicMaterial({ color: CONFIG.colors.lightWarm });
        const lightMatCool = new THREE.MeshBasicMaterial({ color: CONFIG.colors.lightCool });

        // --- å¯¹è±¡ç”Ÿæˆ ---
        const objects = [];
        
        // å‡ ä½•ä½“ç¼“å­˜
        const foliageGeo = new THREE.ConeGeometry(0.25, 0.8, 5, 1); 
        const sphereGeo = new THREE.SphereGeometry(0.35, 32, 32);
        const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const lightGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const photoGeo = new THREE.PlaneGeometry(3, 3.5);

        // è¾…åŠ©å‡½æ•°ï¼šé»„é‡‘è§’åˆ†å¸ƒ
        function getTreePosition(index, total, heightMin, heightMax, maxRadius) {
            const y = heightMin + (heightMax - heightMin) * (index / total);
            // åŠå¾„éšé«˜åº¦å¢åŠ è€Œå‡å°
            const progress = (y - heightMin) / (heightMax - heightMin);
            const r = maxRadius * (1 - progress); 
            // é»„é‡‘è§’
            const theta = index * 2.39996; 
            
            // å¢åŠ ä¸€äº›éšæœºå™ªå£°
            const noiseR = (Math.random() - 0.5) * 0.5;
            const noiseY = (Math.random() - 0.5) * 0.5;

            return new THREE.Vector3(
                Math.cos(theta) * (r + noiseR),
                y + noiseY,
                Math.sin(theta) * (r + noiseR)
            );
        }

        function createParticles() {
            // 1. æ ‘å¶ (æ ‘çš„èº«ä½“)
            for(let i=0; i<CONFIG.counts.foliage; i++) {
                const mesh = new THREE.Mesh(foliageGeo, foliageMat);
                const treePos = getTreePosition(i, CONFIG.counts.foliage, -8, 14, 9);
                treePos.x *= 0.9; treePos.z *= 0.9;
                
                setupParticle(mesh, treePos, 'foliage');
                
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.z = Math.random() * Math.PI;
            }

            // 2. å½©ç¯ (èºæ—‹å¤–å±‚)
            for(let i=0; i<CONFIG.counts.lights; i++) {
                const isWarm = Math.random() > 0.3;
                const mesh = new THREE.Mesh(lightGeo, isWarm ? lightMatWarm : lightMatCool);
                const treePos = getTreePosition(i, CONFIG.counts.lights, -8, 14, 9.5);
                
                setupParticle(mesh, treePos, 'light', {
                    blinkSpeed: Math.random() * 3 + 1,
                    blinkOffset: Math.random() * Math.PI * 2
                });
            }

            // 3. è£…é¥°å“ (éšæœºæ”¾ç½®)
            for(let i=0; i<CONFIG.counts.ornaments; i++) {
                const type = Math.random() > 0.7 ? 'box' : 'sphere';
                const mesh = new THREE.Mesh(
                    type === 'box' ? boxGeo : sphereGeo, 
                    Math.random() > 0.5 ? goldMat : redMat
                );
                
                const treePos = getTreePosition(i, CONFIG.counts.ornaments, -7, 12, 9.2);
                setupParticle(mesh, treePos, 'ornament');
            }

            // 4. ç…§ç‰‡ (æ¼‚æµ®åœ¨å‘¨å›´)
            for(let i=0; i<CONFIG.counts.photos; i++) {
                // åˆå§‹å ä½ç¬¦æ–‡æœ¬
                const initialCaption = `çè´µæ—¶åˆ» ${i + 1}`; 
                const tex = createPhotoTexture(i, initialCaption);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(photoGeo, mat);
                
                const treePos = getTreePosition(i, CONFIG.counts.photos, -6, 12, 10);
                
                setupParticle(mesh, treePos, 'photo');
                STATE.photoObjects.push(mesh); // å­˜å‚¨å¼•ç”¨
            }
        }

        function setupParticle(mesh, treePos, type, extraData = {}) {
            // åˆ†æ•£ä½ç½®ï¼šæ˜Ÿäº‘çŠ¶
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 50 + 10; // å¢å¼º: å¢åŠ åˆ†æ•£èŒƒå›´
            const scatterPos = new THREE.Vector3(
                Math.cos(angle) * dist,
                (Math.random() - 0.5) * 50, // å¢å¼º: å¢åŠ å‚ç›´åˆ†æ•£èŒƒå›´
                Math.sin(angle) * dist
            );

            mesh.position.copy(treePos);
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            
            const baseScale = mesh.scale.x;
            mesh.scale.setScalar(baseScale * (0.8 + Math.random() * 0.4));

            scene.add(mesh);

            objects.push({
                mesh,
                treePos,
                scatterPos,
                type,
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.03,
                    y: (Math.random() - 0.5) * 0.03
                },
                phase: Math.random() * Math.PI * 2,
                baseScale: mesh.scale.x,
                ...extraData
            });
        }

        // --- é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ ---
        function createStar() {
            const group = new THREE.Group();
            // æ˜Ÿæ˜Ÿå‡ ä½•ä½“å’Œæè´¨
            const coreGeo = new THREE.OctahedronGeometry(1.0, 0);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeo, coreMat);
            group.add(core);

            const rayGeo = new THREE.ConeGeometry(0.2, 3, 4);
            const rayMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });
            
            const directions = [
                [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0], [0, 0, 1], [0, 0, -1]
            ];
            
            directions.forEach(dir => {
                const ray = new THREE.Mesh(rayGeo, rayMat);
                const vec = new THREE.Vector3(...dir);
                ray.position.copy(vec.multiplyScalar(1.2));
                ray.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec.normalize());
                group.add(ray);
            });

            const ringGeo = new THREE.TorusGeometry(1.5, 0.05, 8, 32);
            const ring = new THREE.Mesh(ringGeo, rayMat);
            group.add(ring);

            group.position.set(0, 15, 0);
            scene.add(group);
            
            objects.push({
                mesh: group,
                treePos: new THREE.Vector3(0, 15, 0),
                scatterPos: new THREE.Vector3(0, 15, 0),
                type: 'star',
                rotationSpeed: { x: 0.005, y: 0.01 },
                phase: 0,
                baseScale: 1
            });
        }

        createParticles();
        createStar();

        // --- Gemini API åŠŸèƒ½ (AI æ ‡é¢˜ç”Ÿæˆå™¨) ---

        /**
         * è°ƒç”¨ Gemini API ç”Ÿæˆä¸€ä¸ªåˆ›æ„èŠ‚æ—¥æ ‡é¢˜ã€‚
         * å®ç°äº†æŒ‡æ•°é€€é¿ï¼Œå¢åŠ å¥å£®æ€§ã€‚
         * @returns {Promise<string>} ç”Ÿæˆçš„æ ‡é¢˜æ–‡æœ¬ã€‚
         */
        async function generateHolidayCaption() {
            const payload = {
                contents: [{ parts: [{ text: API_CONFIG.userQuery }] }],
                // ä½¿ç”¨ Google æœç´¢è·å–å®æ—¶ã€æ¥åœ°æ°”çš„åˆ›æ„
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: API_CONFIG.systemPrompt }]
                }
            };

            let response;
            let result;
            const maxRetries = 5;
            let delay = 1000;
            const apiUrl = `${API_CONFIG.apiUrl}?key=${API_CONFIG.apiKey}`;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "ğŸ„ èŠ‚æ—¥é­”åŠ›é™ä¸´ï¼";
                        return text.trim();
                    } else if (response.status === 429 && i < maxRetries - 1) {
                        // è¾¾åˆ°é€Ÿç‡é™åˆ¶ï¼Œç­‰å¾…å¹¶é‡è¯•
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // æŒ‡æ•°é€€é¿
                    } else {
                        // éé€Ÿç‡é™åˆ¶é”™è¯¯æˆ–æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
                        console.error("API é”™è¯¯:", response.status, response.statusText);
                        break;
                    }
                } catch (error) {
                    console.error("Fetch å¤±è´¥:", error);
                    break;
                }
            }
            return "ğŸ æ„¿ä½ æ¯å¤©éƒ½é—ªè€€å¦‚æ˜Ÿã€‚"; // å¤±è´¥æ—¶çš„ä¸­æ–‡å¤‡ç”¨æ–‡æœ¬
        }

        const generateBtn = document.getElementById('generate-captions-btn');

        async function handleCaptionGeneration() {
            generateBtn.disabled = true;
            const originalText = generateBtn.innerHTML;
            generateBtn.innerHTML = 'âœ¨ æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...';

            const newCaption = await generateHolidayCaption();
            
            // å¾ªç¯éå†æ‰€æœ‰ç…§ç‰‡ç½‘æ ¼ï¼Œå¹¶ç”¨æ–°æ ‡é¢˜æ›´æ–°å®ƒä»¬çš„æè´¨
            STATE.photoObjects.forEach((mesh) => { 
                // å°†ç”Ÿæˆçš„æ ‡é¢˜åº”ç”¨åˆ°æ‰€æœ‰ç…§ç‰‡ä¸Š
                updatePhotoMaterial(mesh, newCaption); 
            });

            generateBtn.innerHTML = originalText;
            generateBtn.disabled = false;
        }

        
        // --- åˆå§‹åŒ–è®¾ç½® ---
        function setUiReady() {
            const loader = document.getElementById('loading');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
            
            document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹éƒ¨";
            document.getElementById('status-text').style.color = "#44ff88";

            // å¯ç”¨ AI æŒ‰é’®
            const generateBtn = document.getElementById('generate-captions-btn');
            generateBtn.disabled = false;
            generateBtn.innerHTML = 'âœ¨ ç”ŸæˆèŠ‚æ—¥å›å¿†';
            generateBtn.addEventListener('click', handleCaptionGeneration);
        }

        function initializeHands() {
            // MediaPipe åº“ç°åœ¨åº”é€šè¿‡å‰é¢çš„éæ¨¡å— script æ ‡ç­¾åŠ è½½ï¼Œæˆä¸ºå…¨å±€å¯¹è±¡
            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                console.warn("MediaPipe ä¾èµ– (Hands/Camera) å°šæœªåŠ è½½ã€‚é‡æ–°å°è¯•åˆå§‹åŒ–...");
                setTimeout(initializeHands, 500);
                return;
            }

            // ç›´æ¥ä½¿ç”¨å…¨å±€å¯¹è±¡ Hands å’Œ Camera
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            // å¯åŠ¨æ‘„åƒå¤´å’Œ MediaPipe
            cameraUtils.start().then(() => {
                navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                    videoElement.srcObject = stream; // éšè—çš„è¾“å…¥è§†é¢‘
                    previewVideo.srcObject = stream; // å°é¢„è§ˆè§†é¢‘
                    previewVideo.play();
                    setUiReady();
                }).catch(err => {
                    console.error("æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»:", err);
                    document.getElementById('status-text').innerText = "æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ï¼Œæ‰‹åŠ¿æ§åˆ¶ä¸å¯ç”¨";
                    document.getElementById('status-text').style.color = "#ff8888";
                    setUiReady();
                });
            });
        }

        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
        const videoElement = document.getElementById('video-input');
        const previewVideo = document.getElementById('preview-video');
        const statusText = document.getElementById('status-text');
        
        // ç«‹å³å°è¯•åˆå§‹åŒ– MediaPipe
        initializeHands(); 

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                
                // å¹³æ»‘æ›´æ–°æ‰‹éƒ¨ä½ç½®ï¼Œç”¨äºè§†å·®æ•ˆæœ
                STATE.handPosition.x += ((wrist.x - 0.5) * 2 - STATE.handPosition.x) * 0.1;
                STATE.handPosition.y += ((wrist.y - 0.5) * 2 - STATE.handPosition.y) * 0.1;

                // æ ¸å¿ƒæ‰‹åŠ¿è¯†åˆ«
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                // è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡å°–ä¹‹é—´çš„è·ç¦»
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const isPinching = pinchDist < 0.07; // æåˆé˜ˆå€¼

                // è®¡ç®—ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡ (é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡)
                const tips = [8, 12, 16, 20];
                let extendedCount = 0;
                // æ£€æŸ¥æŒ‡å°–è·ç¦»æ‰‹è…•çš„è·ç¦»æ˜¯å¦å¤§äºæŒ‡é—´å…³èŠ‚è·ç¦»æ‰‹è…•çš„è·ç¦»ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦ä¼¸å‡ºï¼‰
                tips.forEach(t => {
                    const dTip = Math.hypot(landmarks[t].x - wrist.x, landmarks[t].y - wrist.y);
                    const dPip = Math.hypot(landmarks[t-2].x - wrist.x, landmarks[t-2].y - wrist.y);
                    if (dTip > dPip + 0.03) extendedCount++;
                });
                
                // æ£€æŸ¥æ¡æ‹³ (æ‹‡æŒ‡å†…æ”¶ä¸”å…¶ä»–æ‰‹æŒ‡æœªä¼¸å‡º)
                // æ¡æ‹³åˆ¤æ–­ï¼šæ‹‡æŒ‡å’Œæ‰‹è…•ä¹‹é—´çš„è·ç¦»è¾ƒè¿‘ï¼Œä¸”ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡å°‘
                const isFist = extendedCount < 2 && Math.hypot(thumbTip.x - wrist.x, thumbTip.y - wrist.y) < 0.15; 

                let newStatus = "";
                let newColor = "";

                if (isPinching) {
                    STATE.mode = 'focus';
                    newStatus = "âœ¨ FREEZE TIME (æ—¶é—´å†»ç»“)";
                    newColor = "#88ccff";
                } else if (extendedCount >= 3) {
                    STATE.mode = 'scatter';
                    newStatus = "ğŸ’¥ SCATTER MODE (åˆ†æ•£ç²’å­)";
                    newColor = "#ff8888";
                } else if (isFist || extendedCount <= 1) { // æ¡æ‹³æˆ–å‡ ä¹æ¡æ‹³
                    STATE.mode = 'tree';
                    newStatus = "ğŸŒ² TREE FORM (èšåˆæ ‘å½¢)";
                    newColor = "#D4AF37";
                }

                if(newStatus && statusText.innerText !== newStatus) {
                    statusText.innerText = newStatus;
                    statusText.style.color = newColor;
                }

                // æ›´æ–°æ’å€¼ç›®æ ‡
                if (STATE.mode === 'tree') STATE.targetLerp = 0;
                else STATE.targetLerp = 1;
            } else {
                // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹éƒ¨
                statusText.innerText = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹éƒ¨";
                statusText.style.color = "#44ff88";
            }
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // å¹³æ»‘è¿‡æ¸¡ (Lerp)
            STATE.currentLerp = THREE.MathUtils.lerp(STATE.currentLerp, STATE.targetLerp, delta * 2.5); // æ›´å¿«çš„è¿‡æ¸¡é€Ÿåº¦

            // æ‘„åƒå¤´è§†å·®æ•ˆæœ
            const targetCamX = Math.sin(time * 0.1) * 15 + (STATE.handPosition.x * -12); // å¢åŠ è§†å·®å¹…åº¦
            const targetCamY = 8 + (STATE.handPosition.y * 9); // å¢åŠ è§†å·®å¹…åº¦
            camera.position.x += (targetCamX - camera.position.x) * 0.03;
            camera.position.y += (targetCamY - camera.position.y) * 0.03;
            camera.lookAt(0, 5, 0);

            // å¯¹è±¡åŠ¨ç”»
            objects.forEach(obj => {
                // 1. ä½ç½®æ’å€¼
                const target = obj.treePos.clone().lerp(obj.scatterPos, STATE.currentLerp);
                
                // æ·»åŠ å™ªå£°/æµ®åŠ¨æ•ˆæœ
                if(STATE.mode === 'tree') {
                    // æ ‘å½¢æ¨¡å¼ä¸‹çš„å¾®é£æ‘†åŠ¨
                    target.x += Math.sin(time * 1 + obj.phase) * 0.1;
                    target.z += Math.cos(time * 0.8 + obj.phase) * 0.1;
                } else if (STATE.mode === 'focus') {
                    // æ—¶é—´å†»ç»“æ¨¡å¼ä¸‹çš„æ…¢é€Ÿæµ®åŠ¨
                    target.y += Math.sin(time * 0.5 + obj.phase) * 0.3;
                    obj.mesh.lookAt(camera.position); // ç…§ç‰‡é¢å‘ç”¨æˆ·
                } else {
                    // åˆ†æ•£æ¨¡å¼ä¸‹çš„æµ®åŠ¨
                    target.y += Math.sin(time + obj.phase) * 0.05;
                }

                obj.mesh.position.lerp(target, 0.08);

                // 2. æ—‹è½¬ä¸ç¼©æ”¾
                obj.mesh.rotation.x += obj.rotationSpeed.x;
                obj.mesh.rotation.y += obj.rotationSpeed.y;

                let scale = obj.baseScale;
                
                // ç‰¹æ€§ï¼šå½©ç¯é—ªçƒ
                if (obj.type === 'light') {
                    const blink = Math.sin(time * obj.blinkSpeed + obj.blinkOffset);
                    // åªæœ‰åœ¨æ ‘å½¢æ¨¡å¼ä¸‹æ‰é—ªçƒï¼Œèšç„¦æ¨¡å¼ä¸‹ä¿æŒç¨³å®š
                    if (STATE.mode === 'tree') {
                         scale = obj.baseScale * (0.5 + (blink + 1) * 0.5); // 0.5 åˆ° 1.5 çš„èŒƒå›´
                    } else if (STATE.mode === 'focus') {
                        scale = obj.baseScale * 1.5; // èšç„¦æ—¶æ›´äº®
                    }
                }

                // ç‰¹æ€§ï¼šç…§ç‰‡æ”¾å¤§
                if (obj.type === 'photo') {
                    if (STATE.mode !== 'tree') scale = obj.baseScale * 1.5;
                    if (STATE.mode === 'focus') scale = obj.baseScale * 1.8;
                }

                obj.mesh.scale.setScalar(scale);
            });

            // åœºæ™¯æ—‹è½¬
            if (STATE.mode === 'tree') {
                scene.rotation.y += 0.003;
            } else if (STATE.mode === 'scatter') {
                scene.rotation.y += 0.001;
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
